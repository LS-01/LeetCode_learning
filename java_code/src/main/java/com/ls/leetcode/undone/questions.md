1、
举例：任意一个数组，找出前 k 大的数。
  
  解法 1：先对这个数组进行排序，然后依次输出前 k 大的数，复杂度将会是 O(nlogn)，其中，n 是数组的元素个数。这是一种直接的办法。
  
  解法 2：使用优先队列，复杂度优化成 O(k + nlogk)。
  
  当数据量很大（即 n 很大），而 k 相对较小的时候，显然，利用优先队列能有效地降低算法复杂度。因为要找出前 k 大的数，并不需要对所有的数进行排序。
  
2、
拓扑排序（Topological Sort）

基本思想

和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。

要能实现拓扑排序，得有几个前提：

图必须是有向图
图里面没有环
拓扑排序一般用来理清具有依赖关系的任务。

举例：假设有三门课程 A、B、C，如果想要学习课程 C 就必须先把课程 B 学完，要学习课程 B，还得先学习课程 A，所以得出课程的学习顺序应该是 A -> B -> C。

实现

将问题用一个有向无环图（DAG, Directed Acyclic Graph）进行抽象表达，定义出哪些是图的顶点，顶点之间如何互相关联。
可以利用广度优先搜索或深度优先搜索来进行拓扑排序。
例题分析

有一个学生想要修完 5 门课程的学分，这 5 门课程分别用 1、2、3、4、5 来表示，现在已知学习这些课程有如下的要求：

课程 2 和 4 依赖于课程 1
课程 3 依赖于课程 2 和 4
课程 4 依赖于课程 1 和 2
课程 5 依赖于课程 3 和 4
那么这个学生应该按照怎样的顺序来学习这 5 门课程呢？

解题思路

可以把 5 门课程看成是一个图里的 5 个顶点，用有向线段按照它们的相互关系连起来，于是得出下面的有向图。

首先可以看到，这个有向图里没有环，无论从哪个顶点出发，都不会再回到那个顶点。并且，这个图里并没有孤岛的出现，因此，我们可以对它进行拓扑排序。

方法就是，一开始的时候，对每个顶点统计它们各自的前驱（也就是入度）：1(0)，2(1)，3(2)，4(1)，5(2)。

img  img

选择其中一个没有前驱（也就是入度为 0）的顶点，在这道题里面，顶点 1 就是我们要找的那个点，将它作为结果输出。同时删除掉该顶点和所有以它作为起始点的有向边，更新顶点的入度表。
接下来，顶点 2 就是下一个没有前驱的顶点，输出顶点 2，并将以它作为起点的有向边删除，同时更新入度表。
再来，顶点 4 成为了没有前驱的顶点，输出顶点 4，删除掉它和顶点 3 和 5 的有向边。
然后，顶点 3 没有了前驱，输出它，并删除它与 5 的有向边。
最后，顶点 5 没有前驱，输出它，于是得出最后的结果为：1，2，4，3，5。
一般来说，一个有向无环图可以有一个或多个拓扑排序的序列。

代码示例

运用广度优先搜索的方法对这个图的结构进行遍历。在构建这个图的过程中，用一个链接矩阵 adj 来表示这个图的结构，用一个 indegree 的数组统计每个顶点的入度，重点看如何实现拓扑排序。

void sort() {
    Queue<Integer> q = new LinkedList(); // 定义一个队列 q

    // 将所有入度为 0 的顶点加入到队列 q
    for (int v = 0; v < V; v++) {
        if (indegree[v] == 0) q.add(v);
    }

    // 循环，直到队列为空
    while (!q.isEmpty()) {
        int v = q.poll();
        // 每次循环中，从队列中取出顶点，即为按照入度数目排序中最小的那个顶点
        print(v);

        // 将跟这个顶点相连的其他顶点的入度减 1，如果发现那个顶点的入度变成了 0，将其加入到队列的末尾
        for (int u = 0; u < adj[v].length; u++) {
            if (--indegree[u] == 0) {
                q.add(u);
            }
        }
    }
}
算法分析

时间复杂度

统计顶点的入度需要 O(n) 的时间，接下来每个顶点被遍历一次，同样需要 O(n) 的时间，所以拓扑排序的时间复杂度是 O(n)。

建议：利用深度优先搜索的方法对这道题实现拓扑排序。

3、
递归算法是一种调用自身函数的算法（二叉树的许多性质在定义上就满足递归）。

 

**举例**：（汉诺塔问题）有三个塔 A、B、C，一开始的时候，在塔 A 上放着 n 个盘子，它们自底向上按照从大到小的顺序叠放。现在要求将塔 A 中所有的盘子搬到塔 C 上，让你打印出搬运的步骤。在搬运的过程中，每次只能搬运一个盘子，另外，任何时候，无论在哪个塔上，大盘子不能放在小盘子的上面。

 

**解法**：


1. 从最终的结果出发，要把 n 个盘子按照大小顺序叠放在塔 C 上，就需要将塔 A 的底部最大的盘子搬到塔 C；
2. 为了实现步骤 1，需要将除了这个最大盘子之外的其余盘子都放到塔 B 上。



由上可知，将原来的问题规模从 n 个盘子变成了 n-1 个盘子，即将 n-1 个盘子转移到塔 B 上。

 

如果一个函数，能将 n 个盘子从塔 A，借助塔 B，搬到塔 C。那么，也可以利用该函数将 n-1 个盘子从塔 A，借助塔 C，搬到塔 B。同理，不断地把问题规模变小，当 n 为 1，也就是只有 1 个盘子的时候，直接打印出步骤。

 

**代码**：



```
void hano(char A, char B, char C, int n) {
    if (n > 0) {
        hano(A, C, B, n - 1);
        move(A, C);
        hano(B, A, C, n - 1);
  }
}
```

由上述总结出递归的算法思想，将一个问题的规模变小，然后再利用从小规模问题中得出的结果，结合当前的值或者情况，得出最终的结果。

 

通俗来说，把要实现的递归函数看成是已经实现好的， 直接利用解决一些子问题，然后需要考虑的就是如何根据子问题的解以及当前面对的情况得出答案。这种算法也被称为自顶向下（Top-Down）的算法。

4、

归纳总结一下递归函数的解题模版。

### **解题步骤**

1. 判断当前情况是否非法，如果非法就立即返回，这一步也被称为完整性检查（Sanity Check）。例如，看看当前处理的情况是否越界，是否出现了不满足条件的情况。通常，这一部分代码都是写在最前面的。
2. 判断是否满足结束递归的条件。在这一步当中，处理的基本上都是一些推导过程当中所定义的初始情况。
3. 将问题的规模缩小，递归调用。在归并排序和快速排序中，我们将问题的规模缩小了一半，而在汉诺塔和解码的例子中，我们将问题的规模缩小了一个。
4. 利用在小规模问题中的答案，结合当前的数据进行整合，得出最终的答案。

**代码实现**

```
function fn(n) {
    // 第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
    }

    // 第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
    }

    // 第三步：缩小问题规模
    result1 = fn(n1)
    result2 = fn(n2)
    ...

    // 第四步: 整合结果
    return combine(result1, result2)
}
```

5、
公式法可以说是计算递归函数复杂度最方便的工具，当递归函数的时间执行函数满足如下的关系式时，我们可以利用公式法：T(n) = a×T(n/b) + f(n)。

其中，f(n) 是每次递归完毕之后额外的计算执行时间。例如，在归并排序中，每次递归处理完两边的数组后，我们需要执行合并的操作，那么这个操作的执行时间就是 f(n)。

当参数 a、b 都确定的时候，光看递归的部分，它的时间复杂度就是：O(n^logba)。

由于时间复杂度求的是上界（upper bound)，通过对比递归部分的时间复杂度和 f(n) 的大小关系，得出最后的整体时间复杂度。牢记以下三种情况和相应公式：

当递归部分的执行时间 nlog(b)a 大于 f(n) 的时候，最终的时间复杂度就是 O(n^logba)。
当递归部分的执行时间 nlog(b)a 小于 f(n) 的时候，最终的时间复杂度就是 f(n)。
当递归部分的执行时间 nlog(b)a 等于 f(n) 的时候，最终的时间复杂度就是 O(n^logba)logn。

6、
回溯
**解题步骤
**

1. 判断当前情况是否非法，如果非法就立即返回；
2. 当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回；
3. 当前情况下，遍历所有可能出现的情况并进行下一步的尝试；
4. 递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试。

### 

**代码模板**

```
function fn(n) {

    // 第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
  }

    // 第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
  }

    // 遍历所有可能出现的情况
    for (all possible cases) {
  
        // 第三步: 尝试下一步的可能性
        solution.push(case)
        // 递归
        result = fn(m)

        // 第四步：回溯到上一步
        solution.pop(case)
    
    }
    
}
```

7、
DFS 遍历 BFS 遍历

8、
判断一个问题能不能称得上是动态规划的问题，需要看它是否同时满足这两个重要的属性：最优子结构（Optimal Substructure）和重叠子问题（Overlapping Sub-problems）

9、
###### 贪婪（Greedy）

贪婪算法的 Wikipedia 定义：是一种在每一步选中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。

优点：对于一些问题，非常直观有效。

缺点：

- 并不是所有问题都能用它去解决；
- 得到的结果并一定不是正确的，因为这种算法容易过早地做出决定，从而没有办法达到最优解。

贪婪算法总是做出在当前看来是最好的选择。即，它不从整体的角度去考虑，仅仅对局部的最优解感兴趣。因此，只有当那些局部最优策略能产生全局最优策略的时候，才能用贪婪算法。

10、
## 例题分析四：不定长的边界

前面介绍的二分搜索的例题都给定了一个具体范围或者区间，那么对于没有给定明确区间的问题能不能运用二分搜索呢？

 

例题：有一段不知道具体长度的日志文件，里面记录了每次登录的时间戳，已知日志是按顺序从头到尾记录的，没有记录日志的地方为空，要求当前日志的长度。

### 解题思路

可以把这个问题看成是不知道长度的数组，数组从头开始记录都是时间戳，到了某个位置就成为了空：{2019-01-14, 2019-01-17, … , 2019-08-04, …. , null, null, null ...}。

 

思路 1：顺序遍历该数组，一直遍历下去，当发现第一个 null 的时候，就知道了日志的总数量。很显然，这是很低效的办法。

 

思路 2：借用二分搜索的思想，反着进行搜索。

1. 一开始设置 low = 0，high = 1
2. 只要 logs[high] 不为 null，high *= 2
3. 当 logs[high] 为 null 的时候，可以在区间 [0, high] 进行普通的二分搜索

### 代码实现

```
// 先通过getUpperBound函数不断地去试探在什么位置会出现空的日志。
int getUpperBound(String[] logs, int high) {
    if (logs[high] == null) {
        return high;
    }
    return getUpperBound(logs, high * 2);
}

// 再运用二分搜索的方法去寻找日志的长度。
int binarySearch(String[] logs, int low, int high) {
    if (low > high) {
        return -1;
    }
  
    int middle = low + (high - low) / 2;
  
    if (logs[middle] == null && logs[middle - 1] != null) {
        return middle;
    }
  
    if (logs[middle] == null) {
        return binarySearch(logs, low, middle - 1);
      } else {
        return binarySearch(logs, middle + 1, high);
    }
}
```

判断是否是日志的结尾很简单，只要当前的日志为空，而前一个日志不为空即可。


11、
###### 判断动态规划

Wikipedia 定义：它既是一种数学优化的方法，同时也是编程的方法。

\1. 是数学优化的方法——最优子结构

动态规划是数学优化的方法指，动态规划要解决的都是问题的最优解。而一个问题的最优解是由它的各个子问题的最优解决定的。

\2. 是编程的方法——重叠子问题

动态规划是编程的方法指，可以借助编程的技巧去保证每个重叠的子问题只会被求解一次。

12、
###### 动态规划面试题分类

运用动态规划去解决问题，最难的地方有两个：

1. 应当采用什么样的数据结构来保存什么样的计算结果
2. 如何利用保存下来的计算结果推导出状态转移方程

第一个难点，不仅是为了避免重复的计算，也是推导状态转移方程的关键。这一难点往往是在把问题规模缩小的过程中进行的。
解决技巧：假设已经把所有子问题的最佳结果都计算出来了，那么只需要考虑，如何根据这些子问题的结果来得出最终的答案。
根据动态规划问题的难易程度，把常见的动态规划面试题分成如下三大类。

## 

###### 线性规划
线性，就是说各个子问题的规模以线性的方式分布，并且子问题的最佳状态或结果可以存储在一维线性的数据结构里，例如一维数组，哈希表等。

解法中，经常会用 dp[i] 去表示第 i 个位置的结果，或者从 0 开始到第 i 个位置为止的最佳状态或结果。例如，最长上升子序列。dp[i] 表示从数组第 0 个元素开始到第i个元素为止的最长的上升子序列。

求解 dp[i] 的复杂程度取决于题目的要求，但是基本上有两种形式。

### **求解 dp[i] 形式一**

第一种形式，当前所求的值仅仅依赖于有限个先前计算好的值，也就是说，dp[i] 仅仅依赖于有限个 dp[j]，其中 j < i。


**举例3**：一个机器人位于一个 网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或向右移动一步。机器人试图到达网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？
说明： 和的值均不超过100。

解法 1：从起点考虑，暴力法。

解法 2：减小问题规模。

分别计算走到它上面的格子以及左边的格子的步数，相加。递推公式为 dp\[i][j]=dp\[i−1][j] + dp\[i][j−1]。

虽然利用一个二维数组去保存计算的结果，但是 dp[i][j] 所表达的意思仍然是线性的，dp\[i][j] 表示从起点到 (i, j) 的总走法。本题不再讨论具体实现。可以看到，dp[i][j] 仅仅依赖于两个先前的状态。

### 求解 dp[i] 形式二

第二种求解 dp[i] 的形式，当前所求的值依赖于所有先前计算好的值，也就是说，dp[i] 是各个 dp[j] 的某种组合，其中 j 由 0 遍历到 i−1。


## 

###### 区间规划

区间规划，就是说各个子问题的规模由不同的区间来定义，一般子问题的最佳状态或结果存储在二维数组里。一般用 dp[i][j] 代表从第 i 个位置到第 j 个位置之间的最佳状态或结果。

解这类问题的时间复杂度一般为多项式时间，对于一个大小为 n 的问题，时间复杂度不会超过 n 的多项式倍数。例如，O(n)=n^k，k 是一个常数，根据题目的不同而定。

LeetCode 第 516 题

关于区间规划，还有很多题目都有用到，例如给定一系列矩阵，求矩阵相乘的总次数最少的相乘方法。 

## 

###### 约束规划

在普通的线性规划和区间规划里，一般题目有两种需求：统计和最优解。

这些题目不会对输出结果中的元素有什么限制，只要满足最终的一个条件就好了。但是在很多情况下，题目会对输出结果的元素添加一定的限制或约束条件，增加了解题的难度。


举例：0-1 背包问题。

给定 n 个物品，每个物品都有各自的价值 vi 和重量 wi，现在给你一个背包，背包所能承受的最大重量是 W，那么往这个背包里装物品，问怎么装能使被带走的物品的价值总和最大。


因为很多人都熟悉这道经典题目，因此不去详细讲解，但是建议大家好好去做一下这道题。

### NP 完全问题

该例题为 NP 完全问题。NP 是 Non-deterministic Polynomial 的缩写，中文是非決定性多项式。通俗一点来说，对于这类问题，我们无法在多项式时间内解答。这个概念很难，但是理解好它能帮助你很好的分析时间复杂度。

### 时间复杂度

时间复杂度并不是表示程序解决问题需要花费的具体时间，而是说程序运行的时间随着问题规模扩大增长的有多快。
 
如果程序具有 O(1) 的时间复杂度，那么，无论问题规模有多大，运行时间都是固定不变的，这个程序就是一个好程序。如果程序运行的时间随着问题规模的扩大线性增长，复杂度是 O(n)，也很不错。还有一些平方数 O(n^2)、立方数 O(n^3) 的复杂度等，比如冒泡排序。另外还有指数级的复杂度，例如 O(2^n)，O(3^n) 等。还有甚至 O(n!) 阶乘级的复杂度，例如全排列算法。分类如下：

- 多项式级别时间复杂度

O(1)、O(n)、O(n×logn)、O(n^2)、O(n^3) 等，可以表示为 n 的多项式的组合

- 非多项式级别时间复杂度

O(2^n)，O(3^n) 等指数级别和 O(n!) 等阶乘级别 。

### 例题分析

回到 0-1 背包问题，经典的解法就是利用动态规划求解，时间复杂度是 O(n×W)。


因为物体的重量 W 是有精度的，如果假设背包的重量是 21.17008，物品的重量精确到了小数点后 5 位，解题的时候，必须对每一个 0.00001 的重量单位分配一个记忆单元，从 0.00000，0.00001，0.00002 一直分配到 21.17008，虽然背包大小只有不到 22，但是一共分配了 210 多万个单元，这是很可怕的计算量和存储量。

而计算机都是用二进制来表示一个数，假设涵盖从 0 到 W 的区间需要 m 位的二进制数，那么 W 就能写成 2m。因此 0-1 背包问题的复杂度就成为了 O(n×2^m)。

现在问题的规模取决于物品的个数以及需要用多少位二进制数来表示背包的重量，很明显，它是一个指数级的计算量，是一个非多项式级别的复杂度。

13、
二分搜索可以用来查找一些模糊的边界。模糊的边界指，边界的值并不等于目标的值，而是大于或者小于目标的值。



例题：从数组 {-2, 0, 1, 4, 7, 9, 10} 中找到第一个大于 6 的数。

### 解题思路

在一个排好序的数组里，判断一个数是不是第一个大于 6 的数，只要它满足如下的条件：

1. 该数要大于 6；
2. 该数有可能是数组里的第一个数，或者它之前的一个数比 6 小。

只要满足了上面的条件就是第一个大于 6 的数。

### 代码实现

```
Integer firstGreaterThan(int[] nums, int target, int low, int high) {
    if (low > high) {
        return null;
    }

    int middle = low + (high - low) / 2;

    //判断 middle 指向的数是否为第一个比 target 大的数时，须同时满足两个条件：middle 这个数必须大于 target；middle 要么是第一个数，要么它之前的数小于或者等于 target。
    if (nums[middle] > target && (middle == 0 || nums[middle - 1] <= target)) {
        return middle;
    }


    if (target < nums[middle]) {
        return firstGreaterThan(nums, target, low, middle - 1);
      } else {
        return firstGreaterThan(nums, target, middle + 1, high);
      }
}
```

14、
3 4 23
- 线性法及优化线性法
- 切分法
- 快速选择算法
- 最小堆法
- 分治法

15、
56 435 
- 合并区间和无重叠区间
- 火星字典
- 基本计算器
区间问题的方法，以及拓扑排序算法，最后实现了一个基本的计算器。

16、
10 84 28
- 正则表达式匹配
- 柱状图中的最大矩形
- 实现 strStr() 函数
正规表达式以及 KMP 算法是重中之重。

17、
336 340 407
- 回文对
- 至多包含 K 个不同字符的最长子串
- 接雨水 II
